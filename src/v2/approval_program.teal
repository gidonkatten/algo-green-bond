#pragma version 2

// IF: App is being created THEN: Store arguments
int 0
txn ApplicationID
==
bz not_creation

// store creator address
byte "Creator"
txn Sender
app_global_put

// verify that 6 arguments passed
txn NumAppArgs
int 8
==
bz failed

// store the start buy date
byte "StartBuyDate"
txna ApplicationArgs 0
btoi
app_global_put

// store the end buy date
byte "EndBuyDate"
txna ApplicationArgs 1
btoi
app_global_put

// store the maturity date
byte "MaturityDate"
txna ApplicationArgs 2
btoi
app_global_put

// store the id of bond
byte "BondID"
txna ApplicationArgs 3
btoi
app_global_put

// store the cost of bond
byte "BondCost"
txna ApplicationArgs 4
btoi
app_global_put

// store the coupon payment value
byte "BondCouponPaymentValue"
txna ApplicationArgs 5
btoi
app_global_put

// store the number of coupon payment installments
byte "BondCouponInstallments"
txna ApplicationArgs 6
btoi
app_global_put

// store the principal of bond
byte "BondPrincipal"
txna ApplicationArgs 7
btoi
app_global_put

// return true as approval
b success


not_creation:
// Handle each possible OnCompletion type. We don't have to worry about
// handling ClearState, because the ClearStateProgram will execute in that
// case, not the ApprovalProgram.

txn OnCompletion
int NoOp
==
bnz handle_noop

txn OnCompletion
int OptIn
==
bnz handle_optin

txn OnCompletion
int CloseOut
==
bnz handle_closeout

txn OnCompletion
int UpdateApplication
==
bnz handle_updateapp

txn OnCompletion
int DeleteApplication
==
bnz handle_deleteapp

//
// Handle NoOp
//
handle_noop:

// 0. call to this stateful contract
gtxn 0 TypeEnum
int appl
==
txn GroupIndex
int 0
==
&&
bz failed

// check if setting stablecoin address
txna ApplicationArgs 0
byte "update"
==
bnz update

// check if buying bond
txna ApplicationArgs 0
byte "buy"
==
bnz buy

// check if trading bond
txna ApplicationArgs 0
byte "trade"
==
bnz trade

// check if claiming coupon
txna ApplicationArgs 0
byte "coupon"
==
bnz coupon

// check if claiming principal
txna ApplicationArgs 0
byte "principal"
==
bnz principal
err

update:
// If before start date then can set the stablecoin contract account address

global LatestTimestamp
byte "StartBuyDate"
app_global_get
<
bz failed
byte "StablecoinEscrowAddr"
txna ApplicationArgs 1
app_global_put
b success

buy:
// verify there are four transactions in atomic transfer
// 0. call to this contract (verified above)
// 1. transfer of bond from bond contract account to buyer
// 2. transfer of algos from buyer to bond contract account (fee of tx1)
// 3. transfer of USDC from buyer to stablecoin contract account (NoOfBonds * BondCost)

global GroupSize
int 4
==

// tx1
gtxn 1 TypeEnum
int axfer
==
&&
gtxn 1 AssetSender
gtxn 1 Sender
==
&&
gtxn 1 AssetReceiver
txn Sender
==
&&
byte "BondID"
app_global_get
gtxn 1 XferAsset
==
&&

// tx2
gtxn 2 TypeEnum
int pay
==
&&
gtxn 2 Sender
txn Sender
==
&&
gtxn 2 Receiver
gtxn 1 Sender
==
&&
gtxn 2 Amount
gtxn 1 Fee
>=
&&

// tx3
gtxn 3 TypeEnum
int axfer
==
&&
gtxn 3 Sender
txn Sender
==
&&
gtxn 3 AssetReceiver
byte "StablecoinEscrowAddr"
app_global_get
==
&&
//VAR_TMPL_STABLECOIN_ID
int 2 // stablecoin id
gtxn 3 XferAsset
==
&&
gtxn 1 AssetAmount // no. of bonds
byte "BondCost" // bond cost
app_global_get
*
gtxn 3 AssetAmount // stablecoin payment
<=
&&

// verify in buy period
global LatestTimestamp
byte "StartBuyDate"
app_global_get
>=
&&
global LatestTimestamp
byte "EndBuyDate"
app_global_get
<=
&&
bz failed

// store in local storage how many bonds owned
int 0
byte "NoOfBondsOwned"
app_local_get // will return 0 if doesn't exist
gtxn 1 AssetAmount // no. of bonds
+
store 0 // store no. of bonds owned
int 0
byte "NoOfBondsOwned"
load 0 // load no. of bonds owned
app_local_put
b success

trade:
// verify there are at least three transactions in atomic transfer
// 0. call to this contract (verified above)
// 1. transfer of bond between third parties
// 2. transfer of algos from sender to bond contract account (fee of tx1)
// 3,4,... Optional (e.g for payment when transfering bonds)

global GroupSize
int 3
>=

// tx1
gtxn 1 TypeEnum
int axfer
==
&&

// tx2
gtxn 2 TypeEnum
int pay
==
&&
bz failed

coupon:
// verify there are three transactions in atomic transfer
// 0. call to this contract (verified above)
// 1. transfer of algos from buyer to stablecoin contract account (fee of tx2)
// 2. transfer of USDC from stablecoin contract account to owner

global GroupSize
int 3
==

// tx1
gtxn 1 TypeEnum
int pay
==
&&
gtxn 1 Sender
txn Sender
==
&&
gtxn 1 Receiver
byte "StablecoinEscrowAddr"
app_global_get
==
&&
gtxn 1 Amount
gtxn 2 Fee
>=
&&

// tx2
gtxn 2 TypeEnum
int axfer
==
&&
gtxn 2 Sender
byte "StablecoinEscrowAddr"
app_global_get
==
&&
gtxn 2 AssetReceiver
txn Sender
==
&&
gtxn 2 AssetAmount
byte "BondCouponPaymentValue"
app_global_get
int 0
byte "NoOfBondsOwned"
app_local_get // will return 0 if doesn't exist
*
==
&&

// verify (Local.NoOfInstallmentsPayed + 1) <= Global.NoOfInstallments
int 0
byte "NoOfBondCouponPayments"
app_local_get // will return 0 if doesn't exist
int 1
+
dup
store 0 // store 'Local.NoOfInstallmentsPayed' + 1
byte "BondCouponInstallments"
app_global_get
<=
bz failed

// verify that the installment time has passed (b <= c):
// a = (MaturityDate - EndBuyDate) / Global.NoOfInstallments
// b = EndBuyDate + (a * (Local.NoOfInstallmentsPayed + 1))
// c = CurrentTime
byte "MaturityDate"
app_global_get
byte "EndBuyDate"
app_global_get
-
byte "BondCouponInstallments"
app_global_get
/
store 1 // store 'a'
byte "EndBuyDate"
app_global_get
load 1 // load 'a'
load 0 // load 'Local.NoOfInstallmentsPayed' + 1
*
+
global LatestTimestamp
<=
bz failed

// store in local storage how many bonds coupon payments
int 0
byte "NoOfBondCouponPayments"
load 0 // load 'Local.NoOfInstallmentsPayed' + 1
app_local_put
b success

principal:
// verify there are four transactions in atomic transfer
// 0. call to this contract (verified above)
// 1. transfer of bond from sender to bond contract account
// 2. transfer of USDC from stablecoin contract account to sender (NoOfBonds * BondPrincipal)
// 3. transfer of algos from sender to contract account (fee of tx1)
// 4. transfer of algos from sender to contract account (fee of tx2)

global GroupSize
int 5
==

// tx1
gtxn 1 TypeEnum
int axfer
==
&&
gtxn 1 AssetSender
txn Sender
==
&&
gtxn 1 AssetReceiver
gtxn 1 Sender
==
&&
byte "BondID"
app_global_get
gtxn 1 XferAsset
==
&&

// tx2
gtxn 2 TypeEnum
int axfer
==
&&
gtxn 2 Sender
byte "StablecoinEscrowAddr"
app_global_get
==
&&
gtxn 2 AssetReceiver
txn Sender
==
&&
//VAR_TMPL_STABLECOIN_ID
int 2 // stablecoin id
gtxn 2 XferAsset
==
&&
gtxn 1 AssetAmount // NoOfBonds
byte "BondPrincipal"
app_global_get
*
gtxn 2 AssetAmount // stablecoin payment
<=
&&

// tx3
gtxn 3 TypeEnum
int pay
==
&&
gtxn 3 Sender
txn Sender
==
&&
gtxn 3 Receiver
gtxn 1 Sender
==
&&
gtxn 3 Amount
gtxn 1 Fee
>=
&&

// tx4
gtxn 4 TypeEnum
int pay
==
&&
gtxn 4 Sender
txn Sender
==
&&
gtxn 4 Receiver
byte "StablecoinEscrowAddr"
app_global_get
==
&&
gtxn 4 Amount
gtxn 2 Fee
>=
&&
bz failed

// verify have collected all coupon payments
int 0
byte "NoOfBondCouponPayments"
app_local_get // will return 0 if doesn't exist
byte "BondCouponInstallments"
app_global_get
==

// verify past maturity date
global LatestTimestamp
byte "MaturityDate"
app_global_get
>=
&&

// verify sending all bonds owned and opting out
int 0
byte "NoOfBondsOwned"
app_local_get
gtxn 1 AssetAmount
==
&&

// store in local storage 0 bonds owned
int 0
byte "NoOfBondsOwned"
int 0 // no. of bonds owned
app_local_put
b success

//
// Handle OptIn
//
handle_optin:

// Approve if optin is only transaction
global GroupSize
int 1
==
bz failed
b success

//
// Handle CloseOut
//
handle_closeout:

//
// Handle DeleteApplication and UpdateApplication
// By default, disallow updating or deleting the app. Add custom authorization
// logic below to allow updating or deletion in certain circumstances.
//
handle_updateapp:
handle_deleteapp:
b failed

// return true as success
success:
int 1
return

// return false as failure
failed:
int 0
return

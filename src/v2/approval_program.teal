#pragma version 2

// IF: App is being created THEN: Store arguments
int 0
txn ApplicationID
==
bz not_creation

// store creator address
byte "Creator"
txn Sender
app_global_put

// verify that 5 arguments passed
txn NumAppArgs
int 5
==
bz failed

// store the start date
byte "StartDate"
txna ApplicationArgs 0
btoi
app_global_put

// store the end date
byte "EndDate"
txna ApplicationArgs 1
btoi
app_global_put

// store the id of bond
byte "BondID"
txna ApplicationArgs 2
btoi
app_global_put

// store the cost of bond
byte "BondCost"
txna ApplicationArgs 3
btoi
app_global_put

// store the principal of bond
byte "BondPrincipal"
txna ApplicationArgs 4
btoi
app_global_put

// return true as approval
b success


not_creation:
// Handle each possible OnCompletion type. We don't have to worry about
// handling ClearState, because the ClearStateProgram will execute in that
// case, not the ApprovalProgram.

txn OnCompletion
int NoOp
==
bnz handle_noop

txn OnCompletion
int OptIn
==
bnz handle_optin

txn OnCompletion
int CloseOut
==
bnz handle_closeout

txn OnCompletion
int UpdateApplication
==
bnz handle_updateapp

txn OnCompletion
int DeleteApplication
==
bnz handle_deleteapp

//
// Handle NoOp
//
handle_noop:

// 0. call to this stateful contract
gtxn 0 TypeEnum
int appl
==
txn GroupIndex
int 0
==
&&
bz failed

// check if buying bond
txna ApplicationArgs 0
byte "buy"
==
bnz buy

// check if trading bond
txna ApplicationArgs 0
byte "trade"
==
bnz trade

// check if claiming coupon
txna ApplicationArgs 0
byte "coupon"
==
bnz coupon

// check if claiming principal
txna ApplicationArgs 0
byte "principal"
==
bnz principal
err

buy:
// verify there are four transactions in atomic transfer
// 0. call to this contract (verified above)
// 1. transfer of bond from contract account to buyer
// 2. transfer of algos from buyer to contract account (fee)
// 3. transfer of USDC from buyer to contract account (BondCost * NoOfBonds)
// + verify before start date
global GroupSize
int 4
==
gtxn 1 TypeEnum
int axfer
==
&&
gtxn 2 TypeEnum
int pay
==
&&
gtxn 2 Amount
gtxn 1 Fee
>=
&&
gtxn 3 TypeEnum
int axfer
==
&&
global LatestTimestamp
byte "StartDate"
app_global_get
<
bz failed

// vefify:
// a) tx1 bond is being transfered - if so must be using stateless
// b) tx1 contract account to buyer

trade:
// verify there are at least three transactions in atomic transfer
// 0. call to this contract (verified above)
// 1. transfer of bond between third parties
// 2. transfer of algos from sender to contract account (fee)
// 3,4,... Optional (e.g for payment when transfering bonds)
global GroupSize
int 3
>=
gtxn 1 TypeEnum
int axfer
==
&&
gtxn 2 TypeEnum
int pay
==
&&
bz failed

coupon:
principal:


//
// Handle OptIn
//
handle_optin:

//
// Handle CloseOut
//
handle_closeout:

//
// Handle DeleteApplication and UpdateApplication
// By default, disallow updating or deleting the app. Add custom authorization
// logic below to allow updating or deletion in certain circumstances.
//
handle_updateapp:
handle_deleteapp:
b failed

// return true as success
success:
int 1
return

// return false as failure
failed:
int 0
return

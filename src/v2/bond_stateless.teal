#pragma version 2

// IF: Single AssetTransfer THEN: Handle Opt-In
global GroupSize
int 1
==
txn TypeEnum
int axfer
==
&&
bnz asset_opt_in

// verify there are at least three transactions in atomic transfer
// 0. call to stateful contract VAR_TMPL_APPID
// 1. transaction from this contract account
// 2,3,... Optional
// NOTE: transaction for fee checked in stateful contract call
global GroupSize
int 3
>=
gtxn 0 TypeEnum
int appl
==
&&
gtxn 0 ApplicationID
//int VAR_TMPL_APPID
int 3 // app id
==
&&
txn GroupIndex
int 1
==
&&
bz failed

// check no rekeying, close-to and asset close-to
gtxn 0 RekeyTo
global ZeroAddress
==
gtxn 1 RekeyTo
global ZeroAddress
==
&&
gtxn 0 CloseRemainderTo
global ZeroAddress
==
&&
gtxn 1 CloseRemainderTo
global ZeroAddress
==
&&
gtxn 0 AssetCloseTo
global ZeroAddress
==
&&
gtxn 1 AssetCloseTo
global ZeroAddress
==
&&
return

asset_opt_in:
// Verify opt-in:
// a) transfers of 0 amount
// b) receiver must be equal to the sender for opt-ins. Know sender is this contract!
// c) fee is max 1000 microalgos
// d) opting into correct asset
// e) reject opt-in after LastValid block
txn AssetAmount
int 0
==
txn Sender
txn AssetReceiver
==
&&
txn Fee
int 1000
<=
&&
txn XferAsset
//int VAR_TMPL_BOND_ID
int 1 // bond id
==
&&
txn LastValid
// int VAR_TMPL_OPTIN_EXPIRING_BLOCK
int 1500 // opt-in expiring block
<
&&

// Prevent Asset Clawback
txn AssetSender
global ZeroAddress
==
&&
// Prevent Asset Close-To
txn AssetCloseTo
global ZeroAddress
==
&&
// Prevent Rekey-To
txn RekeyTo
global ZeroAddress
==
&&
return

// return false as failure
failed:
int 0
return